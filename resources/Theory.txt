+1. Cколько занимают места примитивные типы?

    Целочисленные типы
    byte - 1 байт (-128 <> 127)
    short - 2 байта (-32.768 <> 32.767)
    int - 4 байта (-2.147.483.648 <> 2.147.483.647)
    long - 8 байт (Целое 64 разрядное число)

    Дробные типы
    float - 4 байта (3.4e-038 <> 3.4e+038)
    double - 8 байт (1.7e-308 <> 1.7e+308)

    Логический тип
    boolean - 1 байт (FALSE/TRUE)

    Символ (Беззнаковый тип)
    char - 2 бита (Символ в кодировке UNICODE)

    Ссылочные типы
    Занимаемая память (Например):
    int number = ...
    sizeOf(primitive) = 4 байта
    Integer number = new Integer(...)
    sizeOf(Integer) + sizeOf(reference)

    Обьект состоит из
        Заголовка
        Памяти для примитивных типов
        Памяти для ссылочных типов
        Смещение/Выравнивание

    В 32-х разрядных JVM размер ссылки обычно 4 байта, а в 64-х разрядных — 8 байт. Хотя это условие и не обязательно.

    https://habr.com/ru/post/134102/

+2. Что такое явные и неявные приведения, с чем связано их наличие?
    Типы приведения
    Расширение приведения (автоматически) – преобразование меньшего типа данных в больший размер типа. byte -> short -> char -> int -> long -> float -> double
    Сужение приведения (вручную) – преобразование данных большего размера в тип меньшего размера. double -> float -> long -> int -> char -> short -> byte

    Преобразование к вещественному типу может привести к потере точности из-за нехватки значащих цифр.
    При преобразовании из целых чисел в дробные могут отбрасываться самые младшие части числа.
    Но т.к. смысл дробного числа в том, чтобы хранить приблизительное значение, такое присваивание разрешается.

    (Явное) Вручную
    В этом случае, если вы хотите присвоить значение большего типа данных меньшему типу данных, вы можете выполнить явное приведение или сужение типов.
    Это полезно для несовместимых типов данных, где автоматическое преобразование невозможно.

    (Неявное)
    Тип приведения, когда два типа данных автоматически конвертируются.
    Также известно как неявное преобразование.
    Происходит, когда два типа данных совместимы, а также когда мы присваиваем значение меньшего типа данных большему типу данных.

    (Сюрприз)
    Типы byte, short, char всегда преобразовываются в тип int при взаимодействии между собой.
    Не зря же тип int считается стандартным целочисленным типом.

    (Важный нюанс)
    Операция приведения типа имеет довольно высокий приоритет.

    Устройство чисел в памяти:
    (int)	0b00000000000011110100001001000000 = 1,000,000
    (short)	0b0100001001000000 = 16,960
    (byte)	0b01000000 = 64

    https://javahelp.online/osnovy/privedeniya-tipov-java
    https://javarush.ru/quests/lectures/questsyntaxpro.level07.lecture01

+3. Прямой, дополнительный, обратный код

    Прямой код - способ представления двоичных чисел с фиксированной запятой. Главным образом используется для записи неотрицательных чисел
    (Только неотрицательные числа)
    Прямой код используется главным образом для представления неотрицательных чисел.
    Использование прямого кода для представления отрицательных чисел является неэффективным - очень сложно реализовать арифметические операции и,
    кроме того, в прямом коде два представления нуля - положительный ноль и отрицательный ноль (чего не бывает):

    Обратный код - метод вычислительной математики, позволяющий вычесть одно число из другого, используя только операцию сложения.
    Обратный двоичный код положительного числа состоит из одноразрядного кода знака (битового знака) - 0, за которым следует значение числа.
    Обратный двоичный код отрицательного числа состоит из одноразрядного кода знака (битового знака) - 1, за которым следует инвертированное значение положительного числа.

    Дополнительный код - наиболее распространенный способ представления отрицательных чисел.
    Он позволяет заменить операцию вычитания на операцию сложения и сделать операции сложения и вычитания одинаковыми для знаковых и беззнаковых чисел.
    В дополнительном коде (как и в прямом и обратном) старший разряд отводится для представления знака числа

    1-й способ:
    - инвертируем значение отрицательного числа, записанного в прямом коде (знаковый бит не трогаем)
    - к полученной инверсии прибавляем 1

    https://microkontroller.ru/programmirovanie-mikrokontrollerov-avr/pryamoy-obratnyiy-dopolnitelnyiy-kod-dvoichnogo-chisla/
    https://math.semestr.ru/inf/inverse.php

-4. Как в двоичном виде храняться числа разных типов в памяти (int,float,double)? Как хранятся отрицательные?

    Вещественные числа — это числа, у которых есть дробная часть (она может быть нулевой). Они могут быть положительными или отрицательными.
    Вещественное число  состоит из целой части, дробной части и знака. У положительных чисел знак обычно не указывают явно, а у отрицательных указывают.

    (Числа с плавающей точкой)
    У 32-битных чисел с плавающей точкой (в Java это как раз тип float) точность составляет примерно 24 бита, то есть около 7 знаков после запятой.
    А у 64-битных чисел (в Java это тип double) — точность примерно 53 бита, то есть примерно 16 знаков после запятой.

    https://javarush.ru/groups/posts/2136-ustroystvo-vejshestvennihkh-chisel
    https://habr.com/ru/post/112953/
    https://csharpindepth.com/Articles/FloatingPoint
    https://csharpindepth.com/Articles/Decimal

-5. 2.1.1 сделать другим способом
-6. Почему возникает погрешность при операциях с дробными числами?

    https://habr.com/ru/post/309812/
    https://habr.com/ru/post/266023/
    http://aco.ifmo.ru/el_books/numerical_methods/lectures/app_1.html#:~:text=Погрешность%20возникает%20из-за%20того%2C%20что,учтены%20какие-то%20особенности%20рассматриваемой%20задачи

-7. Чем отличаются unicode ascii utf 8 и utf16

    https://habr.com/ru/post/544084/
    https://javarush.ru/groups/posts/1418-kodirovka-teksta-ascii-windows-1251-cp866-koi8-r-i-junikod-utf-8-16-32--kak-ispravitjh-problemu
    https://askdev.ru/q/v-chem-raznica-mezhdu-ascii-i-unicode-4723/#:~:text=UTF-8%20использует%20набор%20ASCII%20для,UTF%20-8%3A%20минимум%208%20бит

-8. В каких случаях лучше использовать StringBuilder вместо String?

    https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java
    https://habr.com/ru/post/260767/
    https://www.it-rem.ru/string-vs-stringbuilder.html
    https://divancoder.ru/2017/06/string-stringbuffer-stringbuilder/

+9. 2.4.1 решить с помощью рекурсии
-10. Попробовать без стрингбилдера

Дополнительно:
https://habr.com/ru/post/262245/
https://javarush.ru/groups/posts/1924-operacii-nad-chislami-v-java
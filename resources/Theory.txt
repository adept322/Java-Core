1. Cколько занимают места примитивные типы?

    Целочисленные типы
    byte - 1 байт (-128 <> 127)
    short - 2 байта (-32.768 <> 32.767)
    int - 4 байта (-2.147.483.648 <> 2.147.483.647)
    long - 8 байт (Целое 64 разрядное число)

    Дробные типы
    float - 4 байта (3.4e-038 <> 3.4e+038)
    double - 8 байт (1.7e-308 <> 1.7e+308)

    Логический тип
    boolean - 1 байт (FALSE/TRUE)

    Символ (Беззнаковый тип)
    char - 2 бита (Символ в кодировке UNICODE)

    Ссылочные типы
    Занимаемая память (Например):
    int number = ...
    sizeOf(primitive) = 4 байта
    Integer number = new Integer(...)
    sizeOf(Integer) + sizeOf(reference)

    Обьект состоит из
        Заголовка
        Памяти для примитивных типов
        Памяти для ссылочных типов
        Смещение/Выравнивание

    В 32-х разрядных JVM размер ссылки обычно 4 байта, а в 64-х разрядных — 8 байт. Хотя это условие и не обязательно.

    https://habr.com/ru/post/134102/

2. Что такое явные и неявные приведения, с чем связано их наличие?
    Типы приведения
    Расширение приведения (автоматически) – преобразование меньшего типа данных в больший размер типа. byte -> short -> char -> int -> long -> float -> double
    Сужение приведения (вручную) – преобразование данных большего размера в тип меньшего размера. double -> float -> long -> int -> char -> short -> byte

    Преобразование к вещественному типу может привести к потере точности из-за нехватки значащих цифр.
    При преобразовании из целых чисел в дробные могут отбрасываться самые младшие части числа.
    Но т.к. смысл дробного числа в том, чтобы хранить приблизительное значение, такое присваивание разрешается.

    (Явное) Вручную
    В этом случае, если вы хотите присвоить значение большего типа данных меньшему типу данных, вы можете выполнить явное приведение или сужение типов.
    Это полезно для несовместимых типов данных, где автоматическое преобразование невозможно.

    (Неявное)
    Тип приведения, когда два типа данных автоматически конвертируются.
    Также известно как неявное преобразование.
    Происходит, когда два типа данных совместимы, а также когда мы присваиваем значение меньшего типа данных большему типу данных.

    (Сюрприз)
    Типы byte, short, char всегда преобразовываются в тип int при взаимодействии между собой.
    Не зря же тип int считается стандартным целочисленным типом.

    (Важный нюанс)
    Операция приведения типа имеет довольно высокий приоритет.

    Устройство чисел в памяти:
    (int)	0b00000000000011110100001001000000 = 1,000,000
    (short)	0b0100001001000000 = 16,960
    (byte)	0b01000000 = 64

    https://javahelp.online/osnovy/privedeniya-tipov-java
    https://javarush.ru/quests/lectures/questsyntaxpro.level07.lecture01

3. Прямой, дополнительный, обратный код

    https://microkontroller.ru/programmirovanie-mikrokontrollerov-avr/pryamoy-obratnyiy-dopolnitelnyiy-kod-dvoichnogo-chisla/
    https://math.semestr.ru/inf/inverse.php

4. Как в двоичном виде храняться числа разных типов в памяти (int,float,double)? Как хранятся отрицательные?

    https://javarush.ru/groups/posts/2136-ustroystvo-vejshestvennihkh-chisel
    https://habr.com/ru/post/112953/

5. 2.1.1 сделать другим способом
6. Почему возникает погрешность при операциях с дробными числами?

    https://habr.com/ru/post/309812/
    https://habr.com/ru/post/266023/
    http://aco.ifmo.ru/el_books/numerical_methods/lectures/app_1.html#:~:text=Погрешность%20возникает%20из-за%20того%2C%20что,учтены%20какие-то%20особенности%20рассматриваемой%20задачи

7. Чем отличаются unicode ascii utf 8 и utf16

    https://habr.com/ru/post/544084/
    https://javarush.ru/groups/posts/1418-kodirovka-teksta-ascii-windows-1251-cp866-koi8-r-i-junikod-utf-8-16-32--kak-ispravitjh-problemu
    https://askdev.ru/q/v-chem-raznica-mezhdu-ascii-i-unicode-4723/#:~:text=UTF-8%20использует%20набор%20ASCII%20для,UTF%20-8%3A%20минимум%208%20бит

8. В каких случаях лучше использовать StringBuilder вместо String?

    https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java
    https://habr.com/ru/post/260767/
    https://www.it-rem.ru/string-vs-stringbuilder.html
    https://divancoder.ru/2017/06/string-stringbuffer-stringbuilder/

9. 2.4.1 решить с помощью рекурсии
10. Попробовать без стрингбилдера

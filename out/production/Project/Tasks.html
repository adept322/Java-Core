<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8"/>
    <title>Tasks</title>
    <link href="style.css" rel="stylesheet" type="text/css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Blinker:wght@200&family=Ubuntu&display=swap" rel="stylesheet">
</head>
<body>
<div>
    <h1>Модуль №1</h1>
    <hr>
    <h2>Задание №1</h2>
    <p>
        Напишите программу, выводящую в консоль <code>It's alive! It's alive!</code>
        Класс должен называться "Main", это ограничение проверяющей системы.
    </p>

    <code><pre>
            public class Main {
                public static void main(String[] args) {
                    System.out.println("It's alive! It's alive!");
                    System.exit(0);
                }
            }
        </pre>
    </code>
    <hr>
    <h1>Модуль №2</h1>
    <hr>
    <h2>Задание №1</h2>
    <p>
        Реализуйте метод, возвращающий true, если среди четырех его аргументов ровно два истинны (любые). Во всех
        остальных случаях метод должен возвращать false.
        Воспользуйтесь шаблоном кода, который предлагает система. Ввод-вывод будет сделан за вас. Вам надо только
        проанализировать переданные в метод booleanExpression значения (a, b, c, d) и вернуть результат. Попробуйте
        составить формулу с использованием булевых операторов. Если не получается, вернитесь к этому заданию после
        просмотра степов про условные операторы и циклы.
        При записи сложных выражений рекомендуется использовать скобки, чтобы не запутаться в порядке применения
        операторов.
        В качестве примера уже указано заведомо некорректное решение задачи. Исправьте его.
        Совет тем, у кого не проходит какой-то из тестов. В данной задаче возможно всего 16 комбинаций значений входных
        параметров. Их можно выписать на бумажку, посчитать для них правильные ответы и сравнить с тем, что выдает ваше
        решение. Попробуйте самостоятельно проделать это, найти ошибку и исправить решение.
    </p>

    <code><pre>
            public static boolean booleanExpression(boolean a, boolean b, boolean c, boolean d) {
                int s=0;
                if (a) s++;
                if (b) s++;
                if (c) s++;
                if (d) s++;
                return s == 2 ? true : false;
            }
        </pre>
    </code>
    <hr>
    <h2>Задание №2</h2>
    <p>
        В Григорианском календаре год является високосным в двух случаях: либо он кратен 4, но при этом не кратен 100,
        либо кратен 400.
        Реализуйте метод, вычисляющий количество високосных лет с начала нашей эры (первого года) до заданного года
        включительно. На самом деле Григорианский календарь был введен значительно позже, но здесь для упрощения мы
        распространяем его действие на всю нашу эру.
        Ввод-вывод обеспечивает проверяющая система. Вам надо только проанализировать переданное в метод значение и
        вернуть результат. В программу всегда подается положительный номер года. Предполагается решение без циклов. Вам
        надо придумать и записать несложную формулу, использующую только арифметические операторы.
        В качестве примера написано заведомо неправильное выражение. Исправьте его.
    </p>

    <code><pre>
           public static int leapYearCount(int year) {
               return (year - (year % 4)) / 4 - ((year - (year % 100)) / 100 - (year - (year % 400)) / 400);
           }
        </pre>
    </code>
    <hr>
    <h2>Задание №3</h2>
    <p>
        Реализуйте метод, возвращающий ответ на вопрос: правда ли, что a + b = c?
        Допустимая погрешность – 0.0001 (1E-4)
        Можно использовать класс Math и его методы. Класс Math доступен всегда, импортировать его не надо.
        В качестве примера написано заведомо неправильное выражение. Исправьте его.
    </p>

    <code>
        <pre>
            public static boolean doubleExpression(double a, double b, double c) {
                return  java.lang.Math.abs((a + b) - c) < 0.001;
            }
    </pre>
    </code>
    <hr>
    <h2>Задание №4</h2>
    <p>
        Реализуйте метод flipBit, изменяющий значение одного бита заданного целого числа на противоположное. Данная
        задача актуальна, например, при работе с битовыми полями.
        Договоримся, что биты нумеруются от младшего (индекс 1) к старшему (индекс 32).
        Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит
        проверяющая система.
    </p>

    <code><pre>
           /**
            * Flips one bit of the given <code>value</code>.
            *
            * @param value     any number
            * @param bitIndex  index of the bit to flip, 1 <= bitIndex <= 32
            * @return new value with one bit flipped
            */
            public static int flipBit(int value, int bitIndex) {
                return value ^ (1 << (bitIndex - 1));
            }
        </pre>
    </code>
    <hr>
    <h2>Задание №5</h2>
    <p>
        Реализуйте метод, который возвращает букву, стоящую в таблице UNICODE после символа "\" (обратный слэш) на
        расстоянии a.
        В качестве примера написано заведомо неправильное выражение. Исправьте его.
    </p>

    <code>
        <pre>
            public static char charExpression(int a) {
                char symbol = '\\';
                int number = (int) symbol;
                int newSymbol = number + a;
                return (char) newSymbol;
            }
    </pre>
    </code>
    <hr>
    <h2>Задание №6</h2>
    <p>
        Реализуйте метод, проверяющий, является ли заданное число по абсолютной величине степенью двойки.

        Решать можно разными способами:

        1) воспользовавшись одним удобным статическим методом из класса java.lang.Integer;
        2) применив пару трюков из двоичной арифметики;
        3)написав решение "в лоб" с циклом и условными операторами (можете вернуться к этой задаче после просмотра
        соответствующих уроков).
        Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит
        проверяющая система.
    </p>

    <code>
        <pre>
           /**
            * Checks if given <code>value</code> is a power of two.
            *
            * @param value any number
            * @return <code>true</code> when <code>value</code> is power of two, <code>false</code> otherwise
            */
            public static boolean isPowerOfTwo(int value) {
                if (Integer.bitCount(Math.abs(value)) == 1) {
                    return true;
                } else {
                     return false;
                }
            }
    </pre>
    </code>
    <hr>
    <h2>Задание №7</h2>
    <p>
        Реализуйте метод, проверяющий, является ли заданная строка палиндромом. Палиндромом называется строка, которая
        читается одинаково слева направо и справа налево (в том числе пустая). При определении "палиндромности" строки
        должны учитываться только буквы и цифры. А пробелы, знаки препинания, а также регистр символов должны
        игнорироваться. Гарантируется, что в метод попадают только строки, состоящие из символов ASCII (цифры, латинские
        буквы, знаки препинания). Т.е. русских, китайских и прочих экзотических символов в строке не будет.
        Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит
        проверяющая система.
        Подсказки (не читайте, если хотите решить сами):
        для удаления из строки всех символов, не являющихся буквами и цифрами, можно воспользоваться регулярным
        выражением "[^a-zA-Z0-9]"; найдите в классе String метод, выполняющий замену по регулярному выражению;
        для перестановки символов строки в обратном порядке можно воспользоваться методом reverse(), который находится в
        классе StringBuilder;
        в классе String есть методы для преобразования всей строки в верхний и нижний регистр.
    </p>

    <code>
        <pre>
           /**
            * Checks if given <code>text</code> is a palindrome.
            *
            * @param text any string
            * @return <code>true</code> when <code>text</code> is a palindrome, <code>false</code> otherwise
            */
            public static boolean isPalindrome(String text) {
                String newString = text.replaceAll("[^a-zA-Z0-9]","");
                StringBuilder stringBuilderNext = new StringBuilder(newString);
                return newString.equalsIgnoreCase(stringBuilderNext.reverse().toString());
            }
    </pre>
    </code>
    <hr>
    <h2>Задание №8</h2>
    <p>
        Реализуйте метод, вычисляющий факториал заданного натурального числа.
        Факториал NN вычисляется как 1 \cdot 2 \cdot ... \cdot N1⋅2⋅...⋅N.
        Поскольку это очень быстро растущая функция, то даже для небольших NN вместимости типов int и long очень скоро
        не хватит. Поэтому будем использовать BigInteger.
        Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит
        проверяющая система.
    </p>

    <code>
        <pre>
           /**
            * Calculates factorial of given <code>value</code>.
            *
            * @param value positive number
            * @return factorial of <code>value</code>
            */
            public static BigInteger factorial(int value) {
                BigInteger result = BigInteger.ONE;
                for (int i = 1; i < value + 1; i++) {
                    result = result.multiply(BigInteger.valueOf(i));
                }
                return result; // your implementation here
            }
    </pre>
    </code>
    <hr>
    <h2>Задание №9</h2>
    <p>
        Реализуйте метод, сливающий два отсортированных по неубыванию массива чисел в один отсортированный в том же порядке массив. Массивы могут быть любой длины, в том числе нулевой.
        Предполагается, что вы реализуете алгоритм слияния, имеющий линейную сложность: он будет идти по двум исходным массивам и сразу формировать отсортированный результирующий массив. Так, чтобы сортировка полученного массива при помощи Arrays.sort() уже не требовалась. К сожалению, автоматически это не проверить, так что это остается на вашей совести :)
        Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит проверяющая система.
    </p>

    <code>
        <pre>
           /**
    * Merges two given sorted arrays into one
    * HABR
    * @param a1 first sorted array
    * @param a2 second sorted array
    * @return new array containing all elements from a1 and a2, sorted
    */
    public static int[] mergeArrays(int[] a1, int[] a2) {
        int[] a3 = new int[a1.length + a2.length];

        int i=0, j=0;
        for (int k=0; k<a3.length; k++) {

        if (i > a1.length-1) {
            int a = a2[j];
            a3[k] = a; 
            j++;
        }
        else if (j > a2.length-1) {
            int a = a1[i];
            a3[k] = a;
            i++;
        }
        else if (a1[i] < a2[j]) {
            int a = a1[i];
            a3[k] = a;
            i++;
        }
        else {
            int b = a2[j];
            a3[k] = b;
            j++;
        }
    }
    return a3;
}
    </pre>
    </code>
    <hr>
    <h2>Задание №9</h2>
    <p>
        Вам дан список ролей и сценарий пьесы в виде массива строчек.

        Каждая строчка сценария пьесы дана в следующем виде:
        Роль: текст

        Текст может содержать любые символы.

        Напишите метод, который будет группировать строчки по ролям, пронумеровывать их и возвращать результат в виде готового текста (см. пример). Каждая группа распечатывается в следующем виде:

        Роль:
        i) текст
        j) текст2
        ...
        ==перевод строки==

        i и j -- номера строк в сценарии. Индексация строчек начинается с единицы, выводить группы следует в соответствии с порядком ролей. Переводы строк между группами обязательны, переводы строк в конце текста не учитываются.

        Заметим, что вам предстоит обработка огромной пьесы в 50 000 строк для 10 ролей – соответственно, неправильная сборка результирующей строчки может выйти за ограничение по времени.

        Обратите внимание еще на несколько нюансов:

        имя персонажа может встречаться в строке более одного раза, в том числе с двоеточием;
        название одной роли может быть префиксом названия другой роли (например, "Лука" и "Лука Лукич");
        роль, у которой нет реплик, тоже должна присутствовать в выходном файле;
        в качестве перевода строки надо использовать символ '\n' (перевод строки в стиле UNIX);
        будьте внимательны, не добавляйте лишних пробелов в конце строк.
    </p>

    <code>
        <pre>
          private String printTextPerRole(String[] roles, String[] textLines) {
        StringBuilder result = new StringBuilder();
        for (String role : roles) {
            result.append(role + ":\n");
            for (int i = 0; i < textLines.length; i++) {
                if (textLines[i].startsWith(role + ":")) {
                    result.append((i+1) + ")" + textLines[i].substring(role.length() + 1) + "\n");
                }
            }
            result.append("\n");
        }
        return result.toString();
    }
    </pre>
    </code>
    <hr>
</div>
</body>
</html>